

# ðŸ§© Assignment 1 â€” Promise Based API Orchestrator

## ðŸŽ¯ Objective

Test studentsâ€™ understanding of:

* Creating Promises manually
* Chaining (`then/catch/finally`)
* Parallel execution with `Promise.all`
* Error handling & fallback logic

---

## ðŸ“ Problem Statement

You are given three mock API functions:

```js
function fetchUser() {
  return new Promise((resolve) => {
    setTimeout(() => resolve({ id: 1, name: "Mrinal" }), 1000);
  });
}

function fetchPosts(userId) {
  return new Promise((resolve) => {
    setTimeout(() => resolve(["Post 1", "Post 2"]), 1500);
  });
}

function fetchComments() {
  return new Promise((_, reject) => {
    setTimeout(() => reject("Comments API failed âŒ"), 1200);
  });
}
```

---

## ðŸ”§ Tasks

### Task 1 â€” Sequential Flow

Using **Promise chaining (no async/await)**:

1. Fetch the user
2. Using user.id fetch posts
3. Print:

```
User: Mrinal
Posts: Post 1, Post 2
```

---

### Task 2 â€” Parallel Optimization

Fetch **posts and comments in parallel** after user is fetched.

* Use `Promise.allSettled`
* Even if comments fail, posts should still show
* Print:

```
User: Mrinal
Posts: Post 1, Post 2
Comments: Failed to load
```

---

### Task 3 â€” Loading & Cleanup

Show:

```
Loading data...
```

at the start and

```
Done
```

in `.finally()`

---

## ðŸš« Constraints

âŒ No async/await
âŒ No try/catch
âœ… Must use `.then()`, `.catch()`, `.finally()`
âœ… Must use `Promise.allSettled`

---

## â­ Bonus

Implement a **timeout wrapper**:

If any API takes more than **2 seconds**, reject it with:

```
Request timed out
```

---

# ðŸ§© Assignment 2 â€” Async/Await Dashboard Loader

## ðŸŽ¯ Objective

Test:

* async/await flow control
* try/catch error handling
* parallel vs sequential awaits
* custom retry logic
* reusable async utilities

---

## ðŸ“ Problem Statement

You are building a **Student Dashboard Loader**.

Mock APIs:

```js
const delay = (ms) => new Promise(res => setTimeout(res, ms));

async function fetchProfile() {
  await delay(800);
  return { name: "Student A", id: 101 };
}

async function fetchCourses() {
  await delay(1200);
  return ["DSA", "React", "System Design"];
}

let marksCallCount = 0;

async function fetchMarks() {
  await delay(500);
  marksCallCount++;

  if (marksCallCount < 2) {
    throw new Error("Marks API failed");
  }

  return { DSA: 90, React: 85 };
}
```

---

## ðŸ”§ Tasks

### Task 1 â€” Sequential Dashboard Load

Using **async/await**:

1. Fetch profile
2. Fetch courses
3. Fetch marks
4. Print:

```
Loading dashboard...
Name: Student A
Courses: DSA, React, System Design
Marks: { DSA: 90, React: 85 }
```

---

### Task 2 â€” Retry Logic (Important ðŸ”¥)

The `fetchMarks()` API fails **first time**.

Implement a reusable function:

```js
async function retry(fn, retries)
```

Rules:

* Retry the function until success
* Stop after `retries` attempts
* Throw error if all attempts fail

Use it to call `fetchMarks()` with **2 retries**.

---

### Task 3 â€” Parallel Optimization

After fetching profile:

* Fetch **courses and marks in parallel**
* Use `Promise.all`

---

### Task 4 â€” Graceful Error UI

If marks still fail after retries:

```
Marks: Not Available
```

Dashboard should still load.

---

## ðŸš« Constraints

âŒ No `.then()` chaining
âŒ No global variables (except given one)
âœ… Must use `try/catch`
âœ… Must use `Promise.all`
âœ… Must write reusable `retry` utility

---

## â­ Bonus

Add a **performance timer**:

Measure and print:

```
Dashboard loaded in X ms
```

---

